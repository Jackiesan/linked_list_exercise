# Linked Lists
## Goal
+ Singly linked list, doubly linked lists
+ Design a singly linked list with object oriented principles
+ Algorithms on singly linked lists. See exercises below.


## Exercises
Design an algorithm, deduce the space and time complexity and then, author functions to do the following:
For each of the problems below: Assume you are given a singly linked list where each node in the linked list has integer data and a link to the next node.
  1. Add a new node with the specific input data value in the linked list. Insert the new node at the beginning of the linked list
  2. Check if the linked list contains a node with specified input value. Returns true if found, false otherwise.
  3. Return the max value in the linked list. Returns the data value and not the node.
  4. Return the min value in the linked list. Returns the data value and not the node.
  5. Return the count of nodes in the singly linked list.
  6. Return the value of the nth node from the beginning. *n* is the input to the method. 
     Assume indexing starts at 0 while counting to n.
  7. Insert a new node with specific input data value, assuming the linked list is sorted in ascending order.
  8. Print the value of each node in the singly linked list separated by a space.
  9. Delete the first node found with the specified input data value.
  10. Reverse the singly linked list. The nodes should be moved and not just the values in the nodes.
  11. Returns the value at the middle node in the singly linked list. 
      If the node count is even, pick one of the two middle values to return.
  12. Find the nth node from the end of the linked list and return its value. Assume indexing starts at 0 while counting to n.
  13. Check if the linked list has a cycle. A cycle exists if any node in the linked list links to a node already visited. Returns true if a cycle is found, false otherwise.

